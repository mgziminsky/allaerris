/*
 * CurseForge API
 *
 * HTTP API for CurseForge
 *
 * The version of the OpenAPI document: 1.0.250410
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use crate::{
    models::{self, *},
    ErrorResponse, Result,
};

/// struct for passing parameters to the method [`FilesApi::get_files`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetFilesParams<'l1,> {
    pub get_mod_files_request_body: &'l1 GetModFilesRequestBody,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetModFileParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file_changelog`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetModFileChangelogParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file_download_url`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetModFileDownloadUrlParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_files`]
#[derive(Clone, Debug)]
#[cfg_attr(feature = "bon", derive(::bon::Builder))]
pub struct GetModFilesParams<'l4,'l8,> {
    /// The mod id the files belong to
    pub mod_id: u64,
    /// A zero based index of the first item to include in the response, the limit is: (index + pageSize <= 10,000).
    pub index: Option<u32>,
    /// The number of items to include in the response, the default/maximum value is 50.
    pub page_size: Option<u32>,
    /// Filter by game version string
    pub game_version: Option<&'l4 str>,
    /// ModLoaderType enumeration Filter only files associated to a given modloader (Forge, Fabric ...). 
    pub mod_loader_type: Option<ModLoaderType>,
    /// Filter only files that are tagged with versions of the given gameVersionTypeId
    pub game_version_type_id: Option<u32>,
    /// Filter only files older than the given file ID
    pub older_than_project_file_id: Option<u32>,
    /// Filter only files that are of the given release types
    pub release_types: Option<&'l8 Vec<models::FileReleaseType>>,
    /// Filter only files supporting the given platform type
    pub platform_type: Option<PlatformType>,
}


/// struct for typed errors of method [`FilesApi::get_files`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetFilesError {
    #[error("Bad Request")]
    Status400,
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileError {
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file_changelog`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileChangelogError {
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file_download_url`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileDownloadUrlError {
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_files`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFilesError {
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}

pub struct FilesApi<'c>(pub(crate) &'c crate::ApiClient);
impl FilesApi<'_> {
    /// Get a list of files.
    pub async fn get_files(&self, params: &GetFilesParams<'_,>) -> Result<models::GetFilesResponse> {
        #[allow(unused_mut)]
        let mut req_builder = self.0.request(
            reqwest::Method::POST,
            "/v1/mods/files"
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                req_builder = req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                req_builder = req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }

        req_builder = req_builder.json(&params.get_mod_files_request_body);

        let resp = req_builder.send().await?;

        let status = resp.status();
        let content = resp.text().await?;

        if !status.is_client_error() && !status.is_server_error() {
            serde_json::from_str(&content).map_err(Into::into)
        } else {
            #[allow(clippy::match_single_binding)]
            let error = match status.as_u16() {
                400 => GetFilesError::Status400,
                404 => GetFilesError::Status404,
                500 => GetFilesError::Status500,
                _ => GetFilesError::Unknown(serde_json::from_str(&content)?),
            };
            Err(ErrorResponse { status, content, source: Some(error.into()) }.into())
        }
    }
    /// Get a single file of the specified mod.
    pub async fn get_mod_file(&self, params: &GetModFileParams<>) -> Result<models::GetModFileResponse> {
        #[allow(unused_mut)]
        let mut req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}"
            , modId=params.mod_id
            , fileId=params.file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                req_builder = req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                req_builder = req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }


        let resp = req_builder.send().await?;

        let status = resp.status();
        let content = resp.text().await?;

        if !status.is_client_error() && !status.is_server_error() {
            serde_json::from_str(&content).map_err(Into::into)
        } else {
            #[allow(clippy::match_single_binding)]
            let error = match status.as_u16() {
                404 => GetModFileError::Status404,
                500 => GetModFileError::Status500,
                _ => GetModFileError::Unknown(serde_json::from_str(&content)?),
            };
            Err(ErrorResponse { status, content, source: Some(error.into()) }.into())
        }
    }
    /// Get the changelog of a file in HTML format.
    pub async fn get_mod_file_changelog(&self, params: &GetModFileChangelogParams<>) -> Result<models::GetModFileChangelogResponse> {
        #[allow(unused_mut)]
        let mut req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}/changelog"
            , modId=params.mod_id
            , fileId=params.file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                req_builder = req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                req_builder = req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }


        let resp = req_builder.send().await?;

        let status = resp.status();
        let content = resp.text().await?;

        if !status.is_client_error() && !status.is_server_error() {
            serde_json::from_str(&content).map_err(Into::into)
        } else {
            #[allow(clippy::match_single_binding)]
            let error = match status.as_u16() {
                404 => GetModFileChangelogError::Status404,
                500 => GetModFileChangelogError::Status500,
                _ => GetModFileChangelogError::Unknown(serde_json::from_str(&content)?),
            };
            Err(ErrorResponse { status, content, source: Some(error.into()) }.into())
        }
    }
    /// Get a download url for a specific file.
    pub async fn get_mod_file_download_url(&self, params: &GetModFileDownloadUrlParams<>) -> Result<models::GetModFileDownloadUrlResponse> {
        #[allow(unused_mut)]
        let mut req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}/download-url"
            , modId=params.mod_id
            , fileId=params.file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                req_builder = req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                req_builder = req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }


        let resp = req_builder.send().await?;

        let status = resp.status();
        let content = resp.text().await?;

        if !status.is_client_error() && !status.is_server_error() {
            serde_json::from_str(&content).map_err(Into::into)
        } else {
            #[allow(clippy::match_single_binding)]
            let error = match status.as_u16() {
                404 => GetModFileDownloadUrlError::Status404,
                500 => GetModFileDownloadUrlError::Status500,
                _ => GetModFileDownloadUrlError::Unknown(serde_json::from_str(&content)?),
            };
            Err(ErrorResponse { status, content, source: Some(error.into()) }.into())
        }
    }
    /// Get all files of the specified mod.
    pub async fn get_mod_files(&self, params: &GetModFilesParams<'_,'_,>) -> Result<models::GetModFilesResponse> {
        #[allow(unused_mut)]
        let mut req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files"
            , modId=params.mod_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                req_builder = req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                req_builder = req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }

        if let Some(ref param_value) = params.index {
            req_builder = req_builder.query(&[("index", &param_value)]);
        }
        if let Some(ref param_value) = params.page_size {
            req_builder = req_builder.query(&[("pageSize", &param_value)]);
        }
        if let Some(ref param_value) = params.game_version {
            req_builder = req_builder.query(&[("gameVersion", &param_value)]);
        }
        if let Some(ref param_value) = params.mod_loader_type {
            req_builder = req_builder.query(&[("modLoaderType", &param_value)]);
        }
        if let Some(ref param_value) = params.game_version_type_id {
            req_builder = req_builder.query(&[("gameVersionTypeId", &param_value)]);
        }
        if let Some(ref param_value) = params.older_than_project_file_id {
            req_builder = req_builder.query(&[("olderThanProjectFileId", &param_value)]);
        }
        if let Some(param_value) = params.release_types {
            req_builder = match "multi" {
                "multi" => req_builder.query(&param_value.iter().map(|p| ("releaseTypes", p)).collect::<Vec<_>>()),
                _ => req_builder.query(&[("releaseTypes", &param_value.iter().map(|p| p.to_string()).collect::<Vec<_>>().join(","))]),
            };
        }
        if let Some(ref param_value) = params.platform_type {
            req_builder = req_builder.query(&[("platformType", &param_value)]);
        }

        let resp = req_builder.send().await?;

        let status = resp.status();
        let content = resp.text().await?;

        if !status.is_client_error() && !status.is_server_error() {
            serde_json::from_str(&content).map_err(Into::into)
        } else {
            #[allow(clippy::match_single_binding)]
            let error = match status.as_u16() {
                404 => GetModFilesError::Status404,
                500 => GetModFilesError::Status500,
                _ => GetModFilesError::Unknown(serde_json::from_str(&content)?),
            };
            Err(ErrorResponse { status, content, source: Some(error.into()) }.into())
        }
    }
}
