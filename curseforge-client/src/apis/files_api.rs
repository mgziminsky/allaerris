/*
 * CurseForge API
 *
 * HTTP API for CurseForge
 *
 * The version of the OpenAPI document: 1.0.0
 * 
 * Generated by: https://openapi-generator.tech
 */


use crate::{
    models::{self, *},
    ErrorResponse, Result,
};

/// struct for passing parameters to the method [`FilesApi::get_files`]
#[derive(Clone, Debug)]
pub struct GetFilesParams<'l1,> {
    pub get_mod_files_request_body: &'l1 GetModFilesRequestBody,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file`]
#[derive(Clone, Debug)]
pub struct GetModFileParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file_changelog`]
#[derive(Clone, Debug)]
pub struct GetModFileChangelogParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_file_download_url`]
#[derive(Clone, Debug)]
pub struct GetModFileDownloadUrlParams<> {
    /// The mod id the file belongs to
    pub mod_id: u64,
    /// The file id.
    pub file_id: u64,
}

/// struct for passing parameters to the method [`FilesApi::get_mod_files`]
#[derive(Clone, Debug)]
pub struct GetModFilesParams<'l2,> {
    /// The mod id the files belong to
    pub mod_id: u64,
    /// Filter by game version string
    pub game_version: Option<&'l2 str>,
    /// ModLoaderType enumeration Filter only files associated to a given modloader (Forge, Fabric ...). 
    pub mod_loader_type: Option<ModLoaderType>,
    /// Filter only files that are tagged with versions of the given gameVersionTypeId
    pub game_version_type_id: Option<u64>,
    /// A zero based index of the first item to include in the response, the limit is: (index + pageSize <= 10,000).
    pub index: Option<u32>,
    /// The number of items to include in the response, the default/maximum value is 50.
    pub page_size: Option<u32>,
}


/// struct for typed errors of method [`FilesApi::get_files`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetFilesError {
    #[error("Bad Request")]
    Status400(),
    #[error("Not Found")]
    Status404(),
    #[error("Internal Server Error")]
    Status500(),
    #[error("Unrecognized Error")]
    UnknownValue(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileError {
    #[error("Not Found")]
    Status404(),
    #[error("Internal Server Error")]
    Status500(),
    #[error("Unrecognized Error")]
    UnknownValue(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file_changelog`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileChangelogError {
    #[error("Not Found")]
    Status404(),
    #[error("Internal Server Error")]
    Status500(),
    #[error("Unrecognized Error")]
    UnknownValue(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_file_download_url`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFileDownloadUrlError {
    #[error("Not Found")]
    Status404(),
    #[error("Internal Server Error")]
    Status500(),
    #[error("Unrecognized Error")]
    UnknownValue(serde_json::Value),
}
/// struct for typed errors of method [`FilesApi::get_mod_files`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModFilesError {
    #[error("Not Found")]
    Status404(),
    #[error("Internal Server Error")]
    Status500(),
    #[error("Unrecognized Error")]
    UnknownValue(serde_json::Value),
}

pub struct FilesApi<'c>(pub(crate) &'c crate::ApiClient);
impl<'c> FilesApi<'c> {
    /// Get a list of files.
    pub async fn get_files(&self, params: &GetFilesParams<'_,>) -> Result<models::GetFilesResponse> {
        // unwrap the parameters
        let GetFilesParams { get_mod_files_request_body, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::POST,
            "/v1/mods/files"
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(reqwest::header::COOKIE, reqwest::header::HeaderValue::from_str(&cookies.join("; "))?);
            }
        }
        local_var_req_builder = local_var_req_builder.json(get_mod_files_request_body);

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        } else {
            let local_var_entity = serde_json::from_str::<GetFilesError>(&local_var_content).map(|e| Box::new(e) as _).ok();
            let local_var_error = ErrorResponse { status: local_var_status, content: local_var_content, source: local_var_entity };
            Err(local_var_error.into())
        }
    }

    /// Get a single file of the specified mod.
    pub async fn get_mod_file(&self, params: &GetModFileParams<>) -> Result<models::GetModFileResponse> {
        // unwrap the parameters
        let GetModFileParams { mod_id, file_id, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}"
            , modId=mod_id
            , fileId=file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(reqwest::header::COOKIE, reqwest::header::HeaderValue::from_str(&cookies.join("; "))?);
            }
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        } else {
            let local_var_entity = serde_json::from_str::<GetModFileError>(&local_var_content).map(|e| Box::new(e) as _).ok();
            let local_var_error = ErrorResponse { status: local_var_status, content: local_var_content, source: local_var_entity };
            Err(local_var_error.into())
        }
    }

    /// Get the changelog of a file in HTML format.
    pub async fn get_mod_file_changelog(&self, params: &GetModFileChangelogParams<>) -> Result<models::GetModFileChangelogResponse> {
        // unwrap the parameters
        let GetModFileChangelogParams { mod_id, file_id, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}/changelog"
            , modId=mod_id
            , fileId=file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(reqwest::header::COOKIE, reqwest::header::HeaderValue::from_str(&cookies.join("; "))?);
            }
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        } else {
            let local_var_entity = serde_json::from_str::<GetModFileChangelogError>(&local_var_content).map(|e| Box::new(e) as _).ok();
            let local_var_error = ErrorResponse { status: local_var_status, content: local_var_content, source: local_var_entity };
            Err(local_var_error.into())
        }
    }

    /// Get a download url for a specific file.
    pub async fn get_mod_file_download_url(&self, params: &GetModFileDownloadUrlParams<>) -> Result<models::GetModFileDownloadUrlResponse> {
        // unwrap the parameters
        let GetModFileDownloadUrlParams { mod_id, file_id, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files/{fileId}/download-url"
            , modId=mod_id
            , fileId=file_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(reqwest::header::COOKIE, reqwest::header::HeaderValue::from_str(&cookies.join("; "))?);
            }
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        } else {
            let local_var_entity = serde_json::from_str::<GetModFileDownloadUrlError>(&local_var_content).map(|e| Box::new(e) as _).ok();
            let local_var_error = ErrorResponse { status: local_var_status, content: local_var_content, source: local_var_entity };
            Err(local_var_error.into())
        }
    }

    /// Get all files of the specified mod.
    pub async fn get_mod_files(&self, params: &GetModFilesParams<'_,>) -> Result<models::GetModFilesResponse> {
        // unwrap the parameters
        let GetModFilesParams { mod_id, game_version, mod_loader_type, game_version_type_id, index, page_size, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/files"
            , modId=mod_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(reqwest::header::COOKIE, reqwest::header::HeaderValue::from_str(&cookies.join("; "))?);
            }
        }

        if let Some(ref game_version) = game_version {
            local_var_req_builder = local_var_req_builder.query(&[("gameVersion", game_version)]);
        }

        if let Some(ref mod_loader_type) = mod_loader_type {
            local_var_req_builder = local_var_req_builder.query(&[("modLoaderType", mod_loader_type)]);
        }

        if let Some(ref game_version_type_id) = game_version_type_id {
            local_var_req_builder = local_var_req_builder.query(&[("gameVersionTypeId", game_version_type_id)]);
        }

        if let Some(ref index) = index {
            local_var_req_builder = local_var_req_builder.query(&[("index", index)]);
        }

        if let Some(ref page_size) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", page_size)]);
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if !local_var_status.is_client_error() && !local_var_status.is_server_error() {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        } else {
            let local_var_entity = serde_json::from_str::<GetModFilesError>(&local_var_content).map(|e| Box::new(e) as _).ok();
            let local_var_error = ErrorResponse { status: local_var_status, content: local_var_content, source: local_var_entity };
            Err(local_var_error.into())
        }
    }

}
