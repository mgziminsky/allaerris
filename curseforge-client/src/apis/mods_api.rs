/*
 * CurseForge API
 *
 * HTTP API for CurseForge
 *
 * The version of the OpenAPI document: 1.0.240719
 * 
 * Generated by: https://openapi-generator.tech
 */


#[allow(unused_imports)]
use crate::{
    models::{self, *},
    ErrorResponse, Result,
};

/// struct for passing parameters to the method [`ModsApi::get_featured_mods`]
#[derive(Clone, Debug)]
pub struct GetFeaturedModsParams<'l1,> {
    pub get_featured_mods_request_body: &'l1 GetFeaturedModsRequestBody,
}

/// struct for passing parameters to the method [`ModsApi::get_mod`]
#[derive(Clone, Debug)]
pub struct GetModParams<> {
    /// The mod id.
    pub mod_id: u64,
}

/// struct for passing parameters to the method [`ModsApi::get_mod_description`]
#[derive(Clone, Debug)]
pub struct GetModDescriptionParams<> {
    /// The mod id.
    pub mod_id: u64,
}

/// struct for passing parameters to the method [`ModsApi::get_mods`]
#[derive(Clone, Debug)]
pub struct GetModsParams<'l1,> {
    pub get_mods_by_ids_list_request_body: &'l1 GetModsByIdsListRequestBody,
}

/// struct for passing parameters to the method [`ModsApi::search_mods`]
#[derive(Clone, Debug)]
pub struct SearchModsParams<'l4,'l5,'l11,> {
    /// Filter by game id.
    pub game_id: u64,
    /// Filter by section id (discoverable via Categories)
    pub class_id: Option<u64>,
    /// Filter by category id
    pub category_id: Option<u64>,
    /// Filter by game version string
    pub game_version: Option<&'l4 str>,
    /// Filter by free text search in the mod name and author
    pub search_filter: Option<&'l5 str>,
    /// Filter by ModsSearchSortField enumeration
    pub sort_field: Option<ModsSearchSortField>,
    /// 'asc' if sort is in ascending order, 'desc' if sort is in descending order 
    pub sort_order: Option<SortOrder>,
    /// Filter only mods associated to a given modloader (Forge, Fabric ...). Must be coupled with gameVersion. 
    pub mod_loader_type: Option<ModLoaderType>,
    /// Filter only mods that contain files tagged with versions of the given gameVersionTypeId
    pub game_version_type_id: Option<u64>,
    /// Filter only mods that the given authorId is a member of.
    pub author_id: Option<u64>,
    /// Filter by slug (coupled with classId will result in a unique result).
    pub slug: Option<&'l11 str>,
    /// A zero based index of the first item to include in the response, the limit is: (index + pageSize <= 10,000).
    pub index: Option<u32>,
    /// The number of items to include in the response, the default/maximum value is 50.
    pub page_size: Option<u32>,
}


/// struct for typed errors of method [`ModsApi::get_featured_mods`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetFeaturedModsError {
    #[error("Bad Request")]
    Status400,
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`ModsApi::get_mod`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModError {
    #[error("Not found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`ModsApi::get_mod_description`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModDescriptionError {
    #[error("Not Found")]
    Status404,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`ModsApi::get_mods`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum GetModsError {
    #[error("Bad Request")]
    Status400,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}
/// struct for typed errors of method [`ModsApi::search_mods`]
#[derive(Debug, Clone, Serialize, Deserialize, thiserror::Error)]
#[serde(untagged)]
pub enum SearchModsError {
    #[error("Bad Request")]
    Status400,
    #[error("Internal Server Error")]
    Status500,
    #[error("Unrecognized Error")]
    Unknown(serde_json::Value),
}

pub struct ModsApi<'c>(pub(crate) &'c crate::ApiClient);
impl<'c> ModsApi<'c> {
    /// Get a list of featured, popular and recently updated mods.
    pub async fn get_featured_mods(&self, params: &GetFeaturedModsParams<'_,>) -> Result<models::GetFeaturedModsResponse> {
        // unwrap the parameters
        let GetFeaturedModsParams { get_featured_mods_request_body, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::POST,
            "/v1/mods/featured"
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }
        local_var_req_builder = local_var_req_builder.json(get_featured_mods_request_body);

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if local_var_status.is_client_error() || local_var_status.is_server_error() {
            #[allow(clippy::match_single_binding)]
            let local_var_error = match local_var_status.as_u16() {
                400 => GetFeaturedModsError::Status400,
                404 => GetFeaturedModsError::Status404,
                500 => GetFeaturedModsError::Status500,
                _ => GetFeaturedModsError::Unknown(serde_json::from_str(&local_var_content)?),
            };
            Err(ErrorResponse { status: local_var_status, content: local_var_content, source: Some(local_var_error.into()) }.into())
        } else {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        }
    }

    /// Get a single mod.
    pub async fn get_mod(&self, params: &GetModParams<>) -> Result<models::GetModResponse> {
        // unwrap the parameters
        let GetModParams { mod_id, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}"
            , modId=mod_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if local_var_status.is_client_error() || local_var_status.is_server_error() {
            #[allow(clippy::match_single_binding)]
            let local_var_error = match local_var_status.as_u16() {
                404 => GetModError::Status404,
                500 => GetModError::Status500,
                _ => GetModError::Unknown(serde_json::from_str(&local_var_content)?),
            };
            Err(ErrorResponse { status: local_var_status, content: local_var_content, source: Some(local_var_error.into()) }.into())
        } else {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        }
    }

    /// Get the full description of a mod in HTML format.
    pub async fn get_mod_description(&self, params: &GetModDescriptionParams<>) -> Result<models::ModDescriptionResponse> {
        // unwrap the parameters
        let GetModDescriptionParams { mod_id, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            format_args!(
            "/v1/mods/{modId}/description"
            , modId=mod_id
            )
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if local_var_status.is_client_error() || local_var_status.is_server_error() {
            #[allow(clippy::match_single_binding)]
            let local_var_error = match local_var_status.as_u16() {
                404 => GetModDescriptionError::Status404,
                500 => GetModDescriptionError::Status500,
                _ => GetModDescriptionError::Unknown(serde_json::from_str(&local_var_content)?),
            };
            Err(ErrorResponse { status: local_var_status, content: local_var_content, source: Some(local_var_error.into()) }.into())
        } else {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        }
    }

    /// Get a list of mods.
    pub async fn get_mods(&self, params: &GetModsParams<'_,>) -> Result<models::GetModsResponse> {
        // unwrap the parameters
        let GetModsParams { get_mods_by_ids_list_request_body, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::POST,
            "/v1/mods"
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }
        local_var_req_builder = local_var_req_builder.json(get_mods_by_ids_list_request_body);

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if local_var_status.is_client_error() || local_var_status.is_server_error() {
            #[allow(clippy::match_single_binding)]
            let local_var_error = match local_var_status.as_u16() {
                400 => GetModsError::Status400,
                500 => GetModsError::Status500,
                _ => GetModsError::Unknown(serde_json::from_str(&local_var_content)?),
            };
            Err(ErrorResponse { status: local_var_status, content: local_var_content, source: Some(local_var_error.into()) }.into())
        } else {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        }
    }

    /// Get all mods that match the search criteria.
    pub async fn search_mods(&self, params: &SearchModsParams<'_,'_,'_,>) -> Result<models::SearchModsResponse> {
        // unwrap the parameters
        let SearchModsParams { game_id, class_id, category_id, game_version, search_filter, sort_field, sort_order, mod_loader_type, game_version_type_id, author_id, slug, index, page_size, } = params;

        #[allow(unused_mut)]
        let mut local_var_req_builder = self.0.request(
            reqwest::Method::GET,
            "/v1/mods/search"
        );

        // Auth
        #[allow(unused_mut)]
        {
            let auth = &self.0.auth;
            let mut cookies = Vec::<String>::new();
            if let Some(val) = &auth.api_key_auth {
                let mut val = reqwest::header::HeaderValue::from_str(val)?;
                val.set_sensitive(true);
                local_var_req_builder = local_var_req_builder.header("x-api-key", val);
            }
            if !cookies.is_empty() {
                local_var_req_builder = local_var_req_builder.header(
                    reqwest::header::COOKIE,
                    reqwest::header::HeaderValue::from_str(&cookies.join("; "))?
                );
            }
        }

        local_var_req_builder = local_var_req_builder.query(&[("gameId", game_id)]);

        if let Some(ref class_id) = class_id {
            local_var_req_builder = local_var_req_builder.query(&[("classId", class_id)]);
        }

        if let Some(ref category_id) = category_id {
            local_var_req_builder = local_var_req_builder.query(&[("categoryId", category_id)]);
        }

        if let Some(ref game_version) = game_version {
            local_var_req_builder = local_var_req_builder.query(&[("gameVersion", game_version)]);
        }

        if let Some(ref search_filter) = search_filter {
            local_var_req_builder = local_var_req_builder.query(&[("searchFilter", search_filter)]);
        }

        if let Some(ref sort_field) = sort_field {
            local_var_req_builder = local_var_req_builder.query(&[("sortField", sort_field)]);
        }

        if let Some(ref sort_order) = sort_order {
            local_var_req_builder = local_var_req_builder.query(&[("sortOrder", sort_order)]);
        }

        if let Some(ref mod_loader_type) = mod_loader_type {
            local_var_req_builder = local_var_req_builder.query(&[("modLoaderType", mod_loader_type)]);
        }

        if let Some(ref game_version_type_id) = game_version_type_id {
            local_var_req_builder = local_var_req_builder.query(&[("gameVersionTypeId", game_version_type_id)]);
        }

        if let Some(ref author_id) = author_id {
            local_var_req_builder = local_var_req_builder.query(&[("authorId", author_id)]);
        }

        if let Some(ref slug) = slug {
            local_var_req_builder = local_var_req_builder.query(&[("slug", slug)]);
        }

        if let Some(ref index) = index {
            local_var_req_builder = local_var_req_builder.query(&[("index", index)]);
        }

        if let Some(ref page_size) = page_size {
            local_var_req_builder = local_var_req_builder.query(&[("pageSize", page_size)]);
        }

        let local_var_resp = local_var_req_builder.send().await?;

        let local_var_status = local_var_resp.status();
        let local_var_content = local_var_resp.text().await?;

        if local_var_status.is_client_error() || local_var_status.is_server_error() {
            #[allow(clippy::match_single_binding)]
            let local_var_error = match local_var_status.as_u16() {
                400 => SearchModsError::Status400,
                500 => SearchModsError::Status500,
                _ => SearchModsError::Unknown(serde_json::from_str(&local_var_content)?),
            };
            Err(ErrorResponse { status: local_var_status, content: local_var_content, source: Some(local_var_error.into()) }.into())
        } else {
            serde_json::from_str(&local_var_content).map_err(Into::into)
        }
    }

}
